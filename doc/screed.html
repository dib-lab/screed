<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>screed - short read sequence database</title>
<meta name="copyright" content="2008-2010 Michigan State University" />
<meta name="authors" content="Alex Nolley  C. Titus Brown" />
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 5196 2007-06-03 20:25:28Z wiemann $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="screed-short-read-sequence-database">
<h1 class="title">screed - short read sequence database</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Copyright:</th>
<td>2008-2010 Michigan State University</td></tr>
<tr><th class="docinfo-name">Authors:</th>
<td>Alex Nolley
<br />C. Titus Brown</td></tr>
<tr><th class="docinfo-name">Contact:</th>
<td><a class="first reference external" href="mailto:badmit&#64;gmail.com">badmit&#64;gmail.com</a>, <a class="last reference external" href="mailto:ctb&#64;msu.edu">ctb&#64;msu.edu</a></td></tr>
<tr class="field"><th class="docinfo-name">License:</th><td class="field-body">BSD</td>
</tr>
</tbody>
</table>
<!-- contents: -->
<div class="section" id="notes-on-this-document">
<h1>Notes on this document</h1>
<p>This is the default documentation for screed. Some doctests are included
in the file 'example.txt'. The examples in this file are meant for humans
only: they will not work in doctests.</p>
</div>
<div class="section" id="introduction">
<h1>Introduction</h1>
<p>screed is a database generation and querying package made to be used with gene
sequences generated by Solexa machines, namely the FASTQ format, though FASTA
is supported by default as well. Values
such as sequence name, sequence description and the sequence itself can be
retrieved from these databases.</p>
</div>
<div class="section" id="getting-going">
<h1>Getting Going</h1>
<p>The following software packages are required to run screed:</p>
<ul class="simple">
<li>Python 2.4 or newer</li>
<li>nose (for testing)</li>
</ul>
<div class="section" id="downloading">
<h2>Downloading</h2>
<dl class="docutils">
<dt>You will need git to download a copy from the public git repository:</dt>
<dd>git clone git://github.com/acr/screed.git</dd>
</dl>
</div>
<div class="section" id="installing">
<h2>Installing</h2>
<p>Assuming you have already downloaded the package, this is how to install:</p>
<pre class="literal-block">
$ python setup.py install
</pre>
<p>To run the optional tests type:</p>
<pre class="literal-block">
$ python -m screed.tests.__main__
</pre>
</div>
</div>
<div class="section" id="quick-start">
<h1>Quick-Start</h1>
<div class="section" id="creating-a-database-from-the-api">
<h2>Creating a database from the API</h2>
<p>From a Python prompt type:</p>
<pre class="literal-block">
&gt;&gt;&gt; import screed
&gt;&gt;&gt; screed.read_fasta_sequences('screed/tests/test.fa')
</pre>
<p>That command just parsed the FASTA file 'screed/tests/test.fa' into a
screed-database named 'screed/tests/test.fa_screed'. The screed database
is independent from the text file it was derived from, so moving, renaming
or deleting the 'screed/tests/test.fa' file will not affect
screed's operation. To create a screed database from a FASTQ file the
syntax is similar:</p>
<pre class="literal-block">
&gt;&gt;&gt; screed.read_fastq_sequences('screed/tests/test.fastq')
</pre>
</div>
<div class="section" id="creating-a-database-from-a-script">
<h2>Creating a database from a script</h2>
<p>To create a screed db from a FASTQ file at the shell:</p>
<pre class="literal-block">
$ ./fqdbm screed/tests/test.fastq
</pre>
<p>Similarly, to create a screed db from a fasta file:</p>
<pre class="literal-block">
$ ./fadbm screed/tests/test.fa
</pre>
<p>Alternately, if the screed module is in your PATH:</p>
<pre class="literal-block">
$ python -m screed.fadbm &lt;fasta file&gt;
$ python -m screed.fqdbm &lt;fastq file&gt;
</pre>
<p>where &lt;fast* file&gt; is the path to a sequence file.</p>
<p>screed natively supports FASTA and FASTQ database creation. If you have a new
sequence you want screed to work with, see the section below on Writing
Custom Sequence Parsers.</p>
</div>
</div>
<div class="section" id="reading-databases">
<h1>Reading databases</h1>
<p>The class ScreedDB is used to read screed databases, regardless of what file
format they were derived from (FASTA/FASTQ/hava/etc..). One reader to
rule them all!</p>
<div class="section" id="opening">
<h2>Opening</h2>
<p>In the Python environment, import the ScreedDB class and load
some databases:</p>
<pre class="literal-block">
&gt;&gt;&gt; from screed import ScreedDB
&gt;&gt;&gt; fadb = ScreedDB('screed/tests/test.fa')
&gt;&gt;&gt; fqdb = ScreedDB('screed/tests/test.fastq')
</pre>
<p>Notice how you didn't need to write the '_screed' at the end of the file names?
screed automatically adds that to the file name if you didn't.</p>
</div>
<div class="section" id="dictionary-interface">
<h2>Dictionary Interface</h2>
<p>Since screed emulates a read-only dictionary interface, any methods that
don't modify a dictionary are supported:</p>
<pre class="literal-block">
&gt;&gt;&gt; fadb.keys()
&gt;&gt;&gt; fqdb.keys()
</pre>
<p>Each record in the database contains 'fields' such as name and sequence
information. If the database was derived from a FASTQ file, quality and
optional annotation strings are included. Conversely, FASTA-derived
databases have a description field.</p>
<p>To retrieve the names of records in the database:</p>
<pre class="literal-block">
&gt;&gt;&gt; names = fadb.keys()
</pre>
<p>Length of the databases are easily found:</p>
<pre class="literal-block">
&gt;&gt;&gt; print len(fadb)
22
&gt;&gt;&gt; print len(fqdb)
125
</pre>
</div>
<div class="section" id="retrieving-records">
<h2>Retrieving Records</h2>
<p>A record is the standard container unit in screed. Each has 'fields' that
vary slightly depending on what kind of file the database was derived from.
For instance, a FASTQ-derived screed database has an id, a name,
a quality score and a sequence. A FASTA-derived screed database has an
id, name, description and a sequence.</p>
<p>Retrieving whole records:</p>
<pre class="literal-block">
&gt;&gt;&gt; records = []
&gt;&gt;&gt; for record in fadb.itervalues():
&gt;&gt;&gt;     records.append(record)
</pre>
<p>What is returned is a dictionary of fields. The names of fields
are keys into this dictionary with the actual information as values.
For example:</p>
<pre class="literal-block">
&gt;&gt;&gt; record = fadb[fadb.keys()[0]]
&gt;&gt;&gt; index = record['id']
&gt;&gt;&gt; name = record['name']
&gt;&gt;&gt; description = record['description']
&gt;&gt;&gt; sequence = record['sequence']
</pre>
<p>What this does is retrieve the first record object in the screed database,
then retrieve the index, name, description and sequence from the record
object using standard dictionary key -&gt; value pairs.</p>
</div>
<div class="section" id="retrieving-partial-sequences-slicing">
<h2>Retrieving Partial Sequences (slicing)</h2>
<p>screed supports the concept of retrieving a 'slice' or a subset of a
sequence string. The motivation is speed: if you have a database
entry with a very long sequence string but only want a small portion
of the string, it is faster to retrieve only the portion than to
retrieve the entire string and then perform standard Python string
slicing.</p>
<p>By default, screed's FASTA database creator sets up the 'sequence'
column to support slicing. For example, if you have an entry with
name 'someSeq' which has a 10K long sequence, and you want a
slice of the sequence spanning positions 4000 to 4080:</p>
<pre class="literal-block">
&gt;&gt;&gt; seq = db['someSeq'].sequence
&gt;&gt;&gt; slice = seq[4000:4080]
</pre>
<p>This is much faster than say:</p>
<pre class="literal-block">
&gt;&gt;&gt; seq = str(db['someSeq'].sequence)
&gt;&gt;&gt; slice = seq[4000:4080]
</pre>
<p>Because deep down, less information is being read off the disk.
The str() method above causes the entire sequence to be retrieved
as a string. Then Python slicing is done on the string 'seq' and
the subset stored in 'slice'.</p>
</div>
<div class="section" id="retrieving-via-index">
<h2>Retrieving Via Index</h2>
<p>Sometimes you don't care what the name of a sequence is; you're only
interested in its position in the database. In these cases, retrieval via
index is the method you'll want to use:</p>
<pre class="literal-block">
&gt;&gt;&gt; record = fqdb.loadRecordByIndex(5)
</pre>
<p>An index is like an offset into the database. The order records were kept in
the FASTA or FASTQ file determines the index in their resulting screed database.
The first record in a sequence file will have an index of 0, the
second, an index of 1 and so on.</p>
</div>
</div>
<div class="section" id="writing-custom-sequence-parsers">
<h1>Writing Custom Sequence Parsers</h1>
<p>screed is built to be adaptable to new kinds of file sequence formats.
Included with screed are parsers for handling FASTA and FASTQ sequence
file types, though if you need screed to work with a new format,
all you need to do is write a new parser.</p>
<div class="section" id="field-roles">
<h2>Field Roles</h2>
<p>Each field in a screed database is assigned a role. These roles describe what
kind of information is stored in their field. Right now there are only 4
different roles in a screed database: the text role, the sliceable role,
the indexed key role and the primary key role. All roles are defined in the
file: screed/DBConstants.py</p>
<p>The text role (DBConstants._STANDARD_TEXT) is the role most fields in a
database will have. This role tells screed that the associated field is
storing standard textual data. Nothing special.</p>
<p>The sliceable role (DBConstants._SLICEABLE_TEXT) is a role that can be
assigned to long sequence fields. screed's default FASTA parser defines
the 'sequence' field with the sliceable role. When screed retrieves a field
that has the sliceable role, it builds a special data structure that
supports slicing into the text.</p>
<p>The indexed key role (DBConstants._INDEXED_TEXT_KEY) is associated with
exactly one of the fields in a screed database. In screed's FASTA and
FASTQ parsers, this role is fulfilled by the 'name' field. This field
is required because it is the field screed tells sqlite to index when
creating the database and it is the field used for name look-ups when
querying a screed database.</p>
<p>The primary key role (DBConstants._PRIMARY_KEY_ROLE) is a role automatically
associated with the 'id' field in each database. This field is always
created with each screed database and always holds this role. You as a
user of screed won't need to worry about this one.</p>
</div>
<div class="section" id="general-parsing-function-format">
<h2>General Parsing Function Format</h2>
<p>create_db is the function central to the creation of screed databases. This
function accepts a file path, a tuple of field names and roles, and an
iterator function. The file path describes where the screed database should
go, the tuple contains the names of fields and their associated roles and
the iterator function yields records in a dictionary format.</p>
<p>This sub-section describes general steps for preparing and using screed with a
custom sequence parser. Though they don't have to be, future sequence parsers
should be located in the seqparse.py file for convenience.
These steps will be described in the context of working from the Python shell.</p>
<p>First import the create_db function:</p>
<pre class="literal-block">
&gt;&gt;&gt; from screed import create_db
</pre>
<p>The create_db class handles the formatting of screed databases and
provides a simple interface for storing sequence data.</p>
<p>Next the database fields and roles must be specified. The fields tell
screed the names and order of the data fields inside each record. For instance,
lets say our new sequence has types 'name', 'bar', and 'baz', all text. The
tuple will be:</p>
<pre class="literal-block">
&gt;&gt;&gt; fields = (('name', DBConstants._INDEXED_TEXT_KEY),
              ('bar', DBConstants._STANDARD_TEXT),
              ('baz', DBConstants._STANDARD_TEXT))
</pre>
<p>Notice how 'name' is given the indexed key role and bar and baz are
given text roles? If, for instance, you know 'baz' fields can be very long
and you want to be able to retrieve slices of them, you could specify
fields as:</p>
<pre class="literal-block">
&gt;&gt;&gt; fields = (('name', DBConstants._INDEXED_TEXT_KEY),
              ('bar', DBConstants._STANDARD_TEXT),
              ('baz', DBConstants._SLICEABLE_TEXT))
</pre>
<p>All screed databases come with an 'id' field, which is a sequential
numbering order starting at 0 for the first record, 1 for the second, and
so on. The names and number of the other fields are arbitrary with one
restriction: one and only one of the fields must fulfill the indexed key role.</p>
<p>Next, you need to setup an iterator function that will return records in
a dictionary format. Have a look at the 'fastq_iter', 'fasta_iter', or
'hava_iter' functions in the screed/fastq.py, screed/fasta.py, and
screed/hava.py files, respectively for examples on how to write one of these.
If you don't know what an iterator function is, the documentation on the
Python website gives a good description:
<a class="reference external" href="http://docs.python.org/library/stdtypes.html#iterator-types">http://docs.python.org/library/stdtypes.html#iterator-types</a>.</p>
<p>Once the iterator function is written, it needs to be instantiated. In the
context of the built-in parsing functions, this means opening a file and
passing the file handle to the iterator function:</p>
<pre class="literal-block">
&gt;&gt;&gt; seqfile = open('path_to_seq_file', 'rb')
&gt;&gt;&gt; iter_instance = myiter(seqfile)
</pre>
<p>Assuming that your iterator function is called 'myiter', this sets up an
instance of it ready to use with create_db.</p>
<p>Now the screed database is created with one command:</p>
<pre class="literal-block">
&gt;&gt;&gt; create_db('path_to_screed_db', fields, iter_instance)
</pre>
<p>If you want the screed database saved at 'path_to_screed_db'. If instead you
want the screed database created in the same directory and with a
similar file name as the sequence file, its OK to do this:</p>
<pre class="literal-block">
&gt;&gt;&gt; create_db('path_to_seq_file', fields, iter_instance)
</pre>
<p>create_db will just append '_screed' to the end of the file name and make
a screed database at that file path so the original file won't be
overwritten.</p>
<dl class="docutils">
<dt>When you're done the sequence file should be closed::</dt>
<dd><pre class="first last doctest-block">
&gt;&gt;&gt; seqfile.close()
</pre>
</dd>
</dl>
</div>
<div class="section" id="using-the-built-in-sequence-iterator-functions">
<h2>Using the Built-in Sequence Iterator Functions</h2>
<p>This section shows how to use the 'fastq_iter' and 'fasta_iter' functions
for returning records from a sequence file.</p>
<p>These functions both take a file handle as the only argument and then return
a dictionary for each record in the file containing names of fields and
associated data. These functions are primarily used in conjunction with
the db_create() function, but they can be useful by themselves.</p>
<p>First, import the necessary module and open a text file containing sequences.
For this example, the 'fastq_iter' function will be used:</p>
<pre class="literal-block">
&gt;&gt;&gt; import screed.fastq
&gt;&gt;&gt; seqfile = open('path_to_seqfile', 'rb')
</pre>
<p>Now, the 'fastq_iter' can be instantiated and iterated over:</p>
<pre class="literal-block">
&gt;&gt;&gt; fq_instance = screed.fastq(seqfile)
&gt;&gt;&gt; for record in fq_instance:
...     print record.name
</pre>
<p>That will print the name of every sequence in the file. If instead you want
to accumulate the sequences:</p>
<pre class="literal-block">
&gt;&gt;&gt; sequences = []
&gt;&gt;&gt; for record in fq_instance:
...     sequences.append(record.sequence)
</pre>
<p>These iterators are the core of screed's sequence modularity. If there is
a new sequence format you want screed to work with, all it needs is its
own iterator.</p>
</div>
<div class="section" id="error-checking-in-parsing-methods">
<h2>Error checking in parsing methods</h2>
<p>The existing FASTA/FASTQ parsing functions contain some error
checking, such as making sure the file can be opened and checking correct
data is being read. Though screed doesn't enforce this, it is strongly
recommended to include error checking code in your parser. To remain
non-specific to one file sequence type or another, the underlying screed
library can't contain error checking code of this kind. If errors are not
detected by the parsing function, they will be silently included into the
database being built and could cause problems much later when trying to
read from the database.</p>
</div>
</div>
<div class="section" id="file-formats-as-understood-by-screed">
<h1>File formats as understood by screed</h1>
<p>While the screed database remains non-specific to file formats, the included
FASTA and FASTQ parsers expect specific formats. These parsers attempt to
handle the most common attributes of sequence files, though they can not
support all features.</p>
<div class="section" id="fastq">
<h2>FASTQ</h2>
<p>The FASTQ parsing function is read_fastq_sequences() and is located in the
screed module.</p>
<p>The first line in a record must begin with '&#64;' and is
followed by a record identifier (a name). An optional annotations string
may be included after a space on the same line.</p>
<p>The second line begins the sequence line(s) which may be line wrapped.
screed defines no limit on the length of sequence lines and no length on
how many sequence lines a record may contain.</p>
<p>After the sequence line(s) comes a '+' character on a new line. Some
FASTQ formats require the first line to be repeated after the '+'
character, but since this adds no new information to the record,
read_fastq_sequences() will ignore this if it is included.</p>
<p>The quality line(s) is last. Like the sequence line(s) this may
be line wrapped. read_fastq_sequences() will raise an exception if the
quality and sequence strings are of unequal length. screed performs
no checking for valid quality scores.</p>
</div>
<div class="section" id="fasta">
<h2>FASTA</h2>
<p>The FASTA parsing function is read_fasta_sequences() and is also located
in the screed module.</p>
<p>The first line in a record must begin with '&gt;' and is followed with the
sequence's name and an optional description. If the description is
included, it is separated from the name with a space. Note that though
the FASTA format doesn't require named records, screed does. Without a
unique name, screed can't look up sequences by name.</p>
<p>The second line begins the line(s) of sequence. Like the FASTQ parser,
read_fasta_sequences() allows any number of lines of any length.</p>
</div>
</div>
<div class="section" id="fasta-fastq-conversion">
<h1>FASTA &lt;-&gt; FASTQ Conversion</h1>
<p>As an extra nicety, screed can convert FASTA files to FASTQ and back again.</p>
<div class="section" id="fasta-to-fastq">
<h2>FASTA to FASTQ</h2>
<p>The function used for this process is called 'ToFastq' and is located in the
screed module. It takes the path to a screed database as the first argument
and a path to the desired FASTQ file as the second argument. There is also
a shell interface called ToFastq.py:</p>
<pre class="literal-block">
$ ./ToFastq.py &lt;path to fasta db&gt; &lt;converted fastq file&gt;
</pre>
<p>or:</p>
<pre class="literal-block">
$ python -m screed.ToFastq &lt;path to fasta db&gt; &lt;converted fastq file&gt;
</pre>
<p>if the screed module is in your PATH.</p>
<p>The FASTA name attribute is directly dumped from the file. The sequence
attribute is also dumped pretty much directly, but is line wrapped to 80
characters if it is longer.</p>
<p>Any description line in the FASTA database is stored as a FASTQ annotation
string with no other interpretation done.</p>
<p>Finally, as there is no quality or quality score in a FASTA file, a default
one is generated. The generation of the quality follows the Sanger FASTQ
conventions. The score is 1 (ASCII: '&quot;') meaning a probability of about 75%
that the read is incorrect (1 in 4 chance). This PHRED quality score is
calculated from the Sanger format: Q = -10log(p) where p is the probability
of an incorrect read. Obviously this is a very rough way of providing a
quality score and it is only intended to fill in the requirements of a FASTQ
file. Any application needing a true measurement of the quality should
not rely on this automatic conversion.</p>
</div>
<div class="section" id="fastq-to-fasta">
<h2>FASTQ to FASTA</h2>
<p>The function used for this process is called 'toFasta' and is located in the
screed module. It takes the path to a screed database as the first argument
and a path to the desired FASTA file as the second argument. Like the ToFastq
function before, there is a shell interface to ToFasta:</p>
<pre class="literal-block">
$ ./ToFasta.py &lt;path to fastq db&gt; &lt;converted fasta file&gt;
</pre>
<p>or:</p>
<pre class="literal-block">
$ python -m screed.ToFasta &lt;path to fastq db&gt; &lt;converted fasta file&gt;
</pre>
<p>if the screed module is in your PATH.</p>
<p>As above, the name and sequence attributes are directly dumped from the FASTQ
database to the FASTA file with the sequence line wrapping to 80 characters.</p>
<p>If it exists, the FASTQ annotation tag is stored as the FASTA description tag.
As there is no equivalent in FASTA, the FASTQ quality score is ignored.</p>
<!-- Local Variables:
mode: rst
mode: outline-minor
End: -->
</div>
</div>
</div>
</body>
</html>
